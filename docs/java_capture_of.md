## 자바 와일드카드 캡처

<a href="src/capture">예제 코드</a>

비 한정적 와일드 카드 타입을 사용해서 List를 선언하면, 컴파일러는 해당 코드로부터 특정한 타입을 추론한다.

이러한 시나리오를 `wildcard capture` 라고 부른다.

다음과 같은 예시에서 `capture of`라는 메세지가 포함된 에러가 발생한다.

```java
void foo(List<?> i) {
    i.set(0, i.get(0));
}
```

기본적으로 컴파일이 이뤄지고 나면, `i`변수인 `List`는 내부적으로 요소들을 `Object`로 읽을 수 있지만 삽입은 할 수 없다.

왜냐하면 `<?>`의 의미는 "뭔진 모르겠으나 단 하나의 타입으로 결정될 예정임을 암시하기 때문"이다.

마치 상자속에 뭐가 들었는지도 모르는데, 그 속의 값의 타입을 유추할 수 없다. 그렇기때문에 `set, add` 불가능하여 컴파일 에러가 발생한다.

이런 상황에서 헬퍼 메서드를 사용하면 일부 가능토록 할 수 있다.

```java
void foo(List<?> i){
    fooHelper(i);
}

<T> void fooHelper(List<T> i){
    i.set(0, i.get(0));
}
```

위 `fooHelper`와 `foo`메소드 모두 컴파일 되었다고 가정하고 타입을 소거하면

```java
void foo(List i){
    fooHelper(i);
}

void fooHelper(List i){
    i.set(0, i.get(0));
}
```

즉 모두 소거된 뒤는 내부적으로 `Object`로 변환된다.

따라서 인자로 넘기는것도 아무문제가 없고, `fooHelper`는 와일드카드가 아니기 때문에, 특정 하나의 타입임이 명시된다.

결국 `set`메소드와 같은 변조 메소드 사용에 아무문제가 없고, `fooHelper`는 정상적으로 동작하게 된다.

위와같이 뭔지 모르겠지만 특정 하나임을 암시하는 `비 한정적 와일드 카드 타입`에서 변조 메소드를 사용하려면 Helper를 사용하는 경우가 있다.




