## 타입 소거

https://docs.oracle.com/javase/tutorial/java/generics/erasure.html

<a href="src/typeerasure">예제코드</a>

제네릭은 자바언어에서 컴파일시간에 더욱 엄격한 타입 검사를 제공하기 위한것으로 소개되었다.

제네릭을 구현하기 위해서, 자바 컴파일러는 다음에 대한 타입 제거를 적용시켰다.

- 제네릭 타입속의 모든 파라미터는 그들의 경계 혹은 비 경계일 경우 `Object`로 대체된다. 그러므로 제공되는 바이트코드는 오직 보통의 클래스, 인터페이스, 메소드만 포함한다.

- 만약 타입 안전성이 필요하다면 타입 캐스팅을 더한다.

- 확장된 제네릭 타입속 다형성을 보존하기 위해서 브릿지 메소드를 생성한다.

### 제네릭 타입의 소거

타입 소거과정동안, 자바 컴파일러는 모든 타입 파라미터를 제거하고 경계가 있는 파라미터의 경우 마주하는 첫 경계선 그리고 비경계의 경우 `Object`로 대체한다.

```java
public class Node<T> {

    private T data;
    private Node<T> next;

    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }

    public T getData() { return data; }
    // ...
}
```
위와 같은 연결리스트를 구현한 클래스가 컴파일 되면

타입 파라미터 T는 비경계 파라미터이기 때문에, 자바 컴파일러는 `Object`로 대체한다.

```java
public class Node {

    private Object data;
    private Node next;

    public Node(Object data, Node next) {
        this.data = data;
        this.next = next;
    }

    public Object getData() { return data; }
    // ...
}
```

만약 아래와 같이 경계 타입 파라미터를 사용한다면

```java
public class Node<T extends Comparable<T>> {

    private T data;
    private Node<T> next;

    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }

    public T getData() { return data; }
    // ...
}
```

경계 타입파라미터 T는 첫 경계 클래스인 `Comparable`로 대체된다.

```java
public class Node {

    private Comparable data;
    private Node next;

    public Node(Comparable data, Node next) {
        this.data = data;
        this.next = next;
    }

    public Comparable getData() { return data; }
    // ...
}
```

### 제네릭 메소드의 타입소거

자바 컴파일러는 제네릭 메소드 인자속 타입 파라미터도 제거한다.

제네릭 타입의 경우와 동일하게 경계 타입 파라미터의 경우 첫 경계선 클래스로 대체되고, 비경계의 경우 `Object`로 대체된다.

### 타입 제거의 영향과 브릿지 메소드

타입 제거가 발생했을 때, 몇가지 특수한 상황이 있다.

아래와 같은 예제가 있다고 가정해보자.

```java
public class Node<T> {

    public T data;

    public Node(T data) { this.data = data; }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}
```

```java
public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

```java
public class Practice{
    public static void main(){
        MyNode mn = new MyNode(5);
        Node n = mn;

        n.setData("Hello");
        Integer x = (Integer)mn.data;
    }
}
```

만약 저 클래스들을 타입소거 규칙에 의거하여 컴파일된 결과를 해석해보자면

```java
public class Node {

    public Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}
```

```java
public class MyNode extends Node {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

위에서 알 수 있듯, 현재 `setData`메소드 파라미터 타입은 `Integer` 타입과 `Object` 타입이 있다.

별다른 조치가 취해지지 않는다면, `Node`클래스의 `setData`를 호출하게 될 것이고 

결과적으로 다음의 main 메소드에서

```java
public static void main(){
    MyNode mn = new MyNode(5);
    Node n = mn;

    n.setData("Hello");
    Integer x = (Integer)mn.data;
}
```
여기서 사실 `Integer x = (Integer) mn.data` 여기서 에러가 떠야할 것이다. 

왜냐하면 `mn.data`는 사실 `String` 타입 데이터가 들어가게 되니까

그런데 아이러니하게도 `n.setData("Hello")`에 `ClassCastException`이 발생한다.

이를 일으키는 녀석이 바로 브릿지 메소드이다.

사실 대부분의 개발자가 의도한 바는, `setData`메소드 끼리의 오버라이딩을 원했을 것이다.

이러한 다형성문제를 해결하기 위해 자바 컴파일러는 `브릿지 메소드`를 도입하게 된다.

위의 상황에서 의도한 오버라이딩을 일으키기 위해서는 `MyNode` 클래스에 Object타입 파라미터를 받는 `setData`가 필요 할 것이고

개발자가 이를 눈치채지 못한이유는 `Object`타입 파라미터를 받는 브릿지 메소드는 타입만 캐스팅하여 역할을 위임했기 때문이다.

```java
class MyNode extends Node {

    // Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}
```
그래서 setData 과정에서 `ClassCastException`이 발생하게 된다.