## finalizer와 cleaner의 사용을 피하라

나중에 읽어볼 것: https://www.oracle.com/technical-resources/articles/javase/finalization.html

`finalizer`와 `cleaner`는 GC에게 객체 소멸될때 호출하는 메소드로서 보통 해당 객체가 자원을 사용하고 있을때 반환하기 위해 사용한다.

여기서 말하는 자원은 I/O등의 작업을 위한 자원을 의미한다.

결론부터 얘기하자면 저 둘의 메소드는 안전하지 않기 때문에, 자원 회수와 관련된 일이 수행되어야 한다면 `AutoCloseable`을 사용하자.

우선 `finalizer`와 `cleaner`는 다음의 문제점들이 있다.

- `finalizer`는 GC에게 객체 소멸시 메소드를 호출하도록 추가작업이 생기는것 뿐이고, 이 스레드의 우선순위가 높지않아 쌓이게 되면 자원 할당/해제 예외가 발생할 수 있다.

    - `cleaner`는 스레드 제어가 가능하다고는 하지만, 여전히 백그라운드에서 실행되며 GC 통제하에 있으니 즉각실행을 보장하지 못한다.

- `finalizer`는 동작도중 예외가 발생하더라도 예외가 전파되지 않는다. 

    - `cleaner`는 스레드 제어가 가능하기에 위의 문제는 해결할 수 있다.

- `finalizer`와 `cleaner`는 성능문제가 심각하다.

    - `finallizer`의 경우에는 일단 GC에 의해 수거대상이 될 때, 특별한 `finallizer queue`에 이동하여 순차적으로 `finalize()`를 호출하게 된다.

    - `cleaner`도 마찬가지로 한번에 모든 자원을 종료하려 하면 느리다. 하지만 '안전망' 처럼 사용하면 조금은 보완가능하다.

- `finalizer attack`의 위험성을 갖고있다.

    - 이는 생성자에 의해 만들어지던 와중 예외가 발생한 일그러진 객체에 대해서 `finalize`를 사용하여 GC에 의해 수거되지 않게 막을 수 있다.

    - 그래서 온전치 못한 객체를 사용하여 허용되지 않는 작업이 가능하게된다.

    - 이를 막을려면 `final class`이거나 `final class`를 할 수 없다면 `final`로 `finalizer`를 오버라이딩하고 아무것도 작업하지 않게 만들어야 한다.

- `cleaner`의 복잡성

    - `cleaner`는 등록된 객체에 대해서 팬텀 리쳐블로 만들기 때문에 자연스럽게 GC대상이 되도록 유도한다. 

    - 이러한 상황에서 Room 인스턴스에대한 암묵적인 참조가 존재하게 된다면, GC대상에서 벗어나기 때문에 어떠한 경우에도 분리되어있도록 주의해서 구현해야한다.

### 그럼에도 finalizer와 cleaner의 사용처는 두 가지 있다.

사실 `AutoCloseable`에게 대부분을 맡기고 `finalize`나 `cleaner`를 사용할 일이 없을수도 있다.

하지만 `네이티브 피어`의 경우거나 `안전망`의 역할로서 사용한다면 나쁘지 않다.

안전망이란 만약 클라이언트가 명시적인 close() 메소드를 호출하지 않았을 경우의 대비책으로 사용한단 것

아에 안해서 영원히 리소스가 반환되지 않는것보단 낫다.

`네이티브 피어`는 자바의 네이티브 메서드에 의해 네이티브 객체에게 책임을 위임한 형태를 의미한다.

여기서 네이티브 객체는 자바의 GC는 알지못하므로, 이들이 "언젠가" 혹은 "반드시" 종료되길 원한다면(즉각적임은 필요없이) `finalize`나 `cleaner`를 사용하면 된다.








