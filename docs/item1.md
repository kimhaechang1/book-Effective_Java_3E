## 생성자 대신 정적 팩터리 메서드를 고려하라

정적 팩터리 메서드는 해당 클래스의 인스턴스를 반환하는 `static method`를 의미한다.

기존에 `public` 생성자를 통해 인스턴스를 생성하는것 보다 장 단점이 존재한다.

대표적인 정적 팩터리 메서드를 통해 인스턴스를 생성하는 클래스는 `Boolean` Wrapper 클래스이다.

### 1. 이름을 가질 수 있다.

당연한 얘기긴하다. 언제나 클래스명과 같은 이름을 가져야하는 일반적인 생성자와 메소드는 이름을 부여할 수 있다.

해당 클래스의 인스턴스를 생성하려는 클라이언트는 정적 팩토리 메소드의 이름을 통해 "이런 종류의 인스턴스를 만드는 메소드이구나" 라는걸 알게된다.

만약 정적팩토리 메소드를 안쓴다고 했을 때에는, 생성자 오버로딩을 통해 해결하려고 했을 것이다.

이는 생성자 이름만으로 구분할 수 없어 클라이언트가 별도의 API docs를 보고 이해하거나 혹은 이해해서 사용하려고 해도, 너무 다양한 종류의 파라미터로 인해 헷갈릴 것이다.

### 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

즉, 팩토리 메서드를 호출할 때 마다 미리 만들어놓거나 캐싱해놓은 같은 인스턴스를 반환한다는 것이다.

이렇게 인스턴스 생성에 관하여 통제하는 클래스를 `인스턴스 통제 클래스` 라고 한다.

결국 정적 팩터리 메소드를 사용하면 인스턴스를 통제할 수 있음을 의미하는데, 그렇게 하면

단 하나인 인스턴스임이 보장된다는 것은 곧 싱글톤으로 만들수 있고, 

불변 값 클래스에서 동치인 인스턴스가 단 하나임을 보장할 수 있다.

불변 값 클래스의 대표적인 예시로 `Integer` 가 있는데, `new`를 통해 인스턴스를 생성할 수 있고 `valueOf` 정적 팩터리 메소드를 통해 생성할 수 있다.

정적 팩터리 메소드를 통해 생성하면, 같은 값으로 생성한 인스턴스는 내부 캐시에 의해 같은 인스턴스를 반환하게 되고

이는 곧 "값이 같으면 같은 인스턴스"임이 보장되게 된다.

하지만 `new` 를통해 생성자를 직접 만들게 되면, 같은 값이어도 서로다른 인스턴스로 생성되어 같음이 보장되지 않는다.

```java
public class Practice {

    public static void main(String[] args) {
        Integer value2 = Integer.valueOf(1);
        Integer value3 = new Integer(1);
        
        System.out.println(value2 == value3); // false reference value
        System.out.println(value2.equals(value3)); // true value
    }
}
```

### 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

어떤 API를 만드는데 있어서 실제 구현체는 공개하지 않고, 그 객체를 반환할 수 있어 API를 `작게` 유지할 수 있다.

이 `작다`라는 것은 해당 API를 사용하는 사용자 입장에서 다양한 구현체를 알아볼 필요 없이 적은 양의 클래스를 통해 많은 구현체를 얻을 수 있다.

```
컬렉션 프레임워크는 45개의 유틸 구현체가 존재하지만, Collections라는 단 하나의 인스턴스화 불가 클래스를 통해 45개의 구현체에 접근이 가능하게 된다.
```
물론 꼭 별도의 클래스를 만들어서 해야 하냐 라는 입장에서는 (`Collection`과 `Collections`)

인터페이스에 대해 Java 8에서 정적 메소드 생성제한이 풀리고, Java 9에서 프라이빗 정적 메소드까지 허락하지만, 완벽하게 캡슐화 하기엔 부족하다.

### 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

위에서 이어지는 이야기이다. 하위타입 클래스를 특정 목적에 따라 서로다르게 반환할 수 있게 된다.

여기서 하위타입 클래스들은 대체가능한 클래스여야 한다. 

그렇게 만들어놓으면 다음 버전에서 필요성을 못느껴 삭제하더라도 사용자는 이에 따라 변경할 필요가 없다.

### 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 상관없다.

위의 유연함은 `서비스 제공자 프레임워크`를 만드는 근간이 되고, 서비스 제공자 프레임워크의 예시로 `JDBC`가 있다.

JDBC는 크게 드라이버를 제공하는 외부 라이브러리를 구현하는데 필요한 인터페이스인 `Driver`와 

해당 드라이버를 통해 서비스에 접근하는 객체를 생성하는 `DriverManager`가 있다.

어찌보면 `Driver`는 외부 라이브러리와 가까운 인터페이스이고, `DriverManager`는 사용자와 가까운 인터페이스이다.

중요한 부분은 서비스를 접근하는 API가 포함된 객체를 얻는 `DriverManager`의 `getConnection` 정적 팩터리 메서드는 어떤 `Driver`로 부터의 `Connection` 든지 상관없다. 단지 `Connection`클래스의 하위 클래스의 객체이기만 하면 상관이 없다.

위 내용을 보충하는 이야기

https://sihyung92.oopy.io/java/service-provider-framework


여기까지가 장점이고 단점은 두가지가 있는데

1. 상속을 하려면 `public`혹은 `protected` 생성자가 필요하기에, 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
    - 어찌보면 이 제약은 상속보다는 `합성을 사용하도록 유도`하고, `불변 타입`을 만드는데 있어서는 장점이다.

2. 정적 팩터리 메서드는 프로그래머가 찾기 힘들다.
    -  따라서 이부분을 완화 하기위해 아래에 나오는 네이밍 규칙을 따르는 것이 좋다.

### 네이밍 규칙

- `from`: 매개변수를 하나 받아서 인스턴스를 반환하는 형태

- `of`: 여러 매개변수를 집계하여 인스턴스를 반환하는 형태로 `from`과는 갯수 차이

- `valueOf`: `from`과 `of`보다는 더 자세한 버전

- `instance` 혹은 `getInstance`: 매개변수에 따라 여러다른 버전이 존재하며, 같은 인스턴스임이 보장되지 않는다.

- `create` 혹은 `newInstance`: `instance`와 `getInstance`와의 차이는 매번 새로운 인스턴스를 생성한다는 것

- `get<Type>`: `getInstance`와 같으며 `<Type>`에 해당하는 클래스의 정적 팩토리 메소드를 정의할때 사용한다.

    ```java
    FileStore fs = Files.getFileStore(path); // Files 객체가 아닌 FileStore 객체를 얻는다.
    ```
- `new<Type>`: `newInstance`와 같으며 `<Type>`에 해당하는 클래스의 정적 팩토리 메소드를 정의할때 사용한다.

- `<type>`: 위의 `get<Type>`과 `new<Type>`의 간결한 버전
    ```java
    List list = Collections.list();
    ```